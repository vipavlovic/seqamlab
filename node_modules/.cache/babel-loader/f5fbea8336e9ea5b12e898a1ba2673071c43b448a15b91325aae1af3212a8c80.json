{"ast":null,"code":"/* start bibtexParse 0.0.24 */\n\n//Original work by Henrik Muehe (c) 2010\n//\n//CommonJS port by Mikola Lysenko 2013\n//\n//Port to Browser lib by ORCID / RCPETERS\n//\n//Issues:\n//no comment handling within strings\n//no string concatenation\n//no variable values yet\n//Grammar implemented here:\n//bibtex -> (string | preamble | comment | entry)*;\n//string -> '@STRING' '{' key_equals_value '}';\n//preamble -> '@PREAMBLE' '{' value '}';\n//comment -> '@COMMENT' '{' value '}';\n//entry -> '@' key '{' key ',' key_value_list '}';\n//key_value_list -> key_equals_value (',' key_equals_value)*;\n//key_equals_value -> key '=' value;\n//value -> value_quotes | value_braces | key;\n//value_quotes -> '\"' .*? '\"'; // not quite\n//value_braces -> '{' .*? '\"'; // not quite\n(function (exports) {\n  function BibtexParser() {\n    this.months = [\"jan\", \"feb\", \"mar\", \"apr\", \"may\", \"jun\", \"jul\", \"aug\", \"sep\", \"oct\", \"nov\", \"dec\"];\n    this.notKey = [',', '{', '}', ' ', '='];\n    this.pos = 0;\n    this.input = \"\";\n    this.entries = new Array();\n    this.currentEntry = \"\";\n    this.setInput = function (t) {\n      this.input = t;\n    };\n    this.getEntries = function () {\n      return this.entries;\n    };\n    this.isWhitespace = function (s) {\n      return s == ' ' || s == '\\r' || s == '\\t' || s == '\\n';\n    };\n    this.match = function (s, canCommentOut) {\n      if (canCommentOut == undefined || canCommentOut == null) canCommentOut = true;\n      this.skipWhitespace(canCommentOut);\n      if (this.input.substring(this.pos, this.pos + s.length) == s) {\n        this.pos += s.length;\n      } else {\n        throw \"Token mismatch, expected \" + s + \", found \" + this.input.substring(this.pos);\n      }\n      ;\n      this.skipWhitespace(canCommentOut);\n    };\n    this.tryMatch = function (s, canCommentOut) {\n      if (canCommentOut == undefined || canCommentOut == null) canCommentOut = true;\n      this.skipWhitespace(canCommentOut);\n      if (this.input.substring(this.pos, this.pos + s.length) == s) {\n        return true;\n      } else {\n        return false;\n      }\n      ;\n      this.skipWhitespace(canCommentOut);\n    };\n\n    /* when search for a match all text can be ignored, not just white space */\n    this.matchAt = function () {\n      while (this.input.length > this.pos && this.input[this.pos] != '@') {\n        this.pos++;\n      }\n      ;\n      if (this.input[this.pos] == '@') {\n        return true;\n      }\n      ;\n      return false;\n    };\n    this.skipWhitespace = function (canCommentOut) {\n      while (this.isWhitespace(this.input[this.pos])) {\n        this.pos++;\n      }\n      ;\n      if (this.input[this.pos] == \"%\" && canCommentOut == true) {\n        while (this.input[this.pos] != \"\\n\") {\n          this.pos++;\n        }\n        ;\n        this.skipWhitespace(canCommentOut);\n      }\n      ;\n    };\n    this.value_braces = function () {\n      var bracecount = 0;\n      this.match(\"{\", false);\n      var start = this.pos;\n      var escaped = false;\n      while (true) {\n        if (!escaped) {\n          if (this.input[this.pos] == '}') {\n            if (bracecount > 0) {\n              bracecount--;\n            } else {\n              var end = this.pos;\n              this.match(\"}\", false);\n              return this.input.substring(start, end);\n            }\n            ;\n          } else if (this.input[this.pos] == '{') {\n            bracecount++;\n          } else if (this.pos >= this.input.length - 1) {\n            throw \"Unterminated value\";\n          }\n          ;\n        }\n        ;\n        if (this.input[this.pos] == '\\\\' && escaped == false) escaped = true;else escaped = false;\n        this.pos++;\n      }\n      ;\n    };\n    this.value_comment = function () {\n      var str = '';\n      var brcktCnt = 0;\n      while (!(this.tryMatch(\"}\", false) && brcktCnt == 0)) {\n        str = str + this.input[this.pos];\n        if (this.input[this.pos] == '{') brcktCnt++;\n        if (this.input[this.pos] == '}') brcktCnt--;\n        if (this.pos >= this.input.length - 1) {\n          throw \"Unterminated value:\" + this.input.substring(start);\n        }\n        ;\n        this.pos++;\n      }\n      ;\n      return str;\n    };\n    this.value_quotes = function () {\n      this.match('\"', false);\n      var start = this.pos;\n      var escaped = false;\n      while (true) {\n        if (!escaped) {\n          if (this.input[this.pos] == '\"') {\n            var end = this.pos;\n            this.match('\"', false);\n            return this.input.substring(start, end);\n          } else if (this.pos >= this.input.length - 1) {\n            throw \"Unterminated value:\" + this.input.substring(start);\n          }\n          ;\n        }\n        if (this.input[this.pos] == '\\\\' && escaped == false) escaped = true;else escaped = false;\n        this.pos++;\n      }\n      ;\n    };\n    this.single_value = function () {\n      var start = this.pos;\n      if (this.tryMatch(\"{\")) {\n        return this.value_braces();\n      } else if (this.tryMatch('\"')) {\n        return this.value_quotes();\n      } else {\n        var k = this.key();\n        if (k.match(\"^[0-9]+$\")) return k;else if (this.months.indexOf(k.toLowerCase()) >= 0) return k.toLowerCase();else throw \"Value expected:\" + this.input.substring(start) + ' for key: ' + k;\n      }\n      ;\n    };\n    this.value = function () {\n      var values = [];\n      values.push(this.single_value());\n      while (this.tryMatch(\"#\")) {\n        this.match(\"#\");\n        values.push(this.single_value());\n      }\n      ;\n      return values.join(\"\");\n    };\n    this.key = function (optional) {\n      var start = this.pos;\n      while (true) {\n        if (this.pos >= this.input.length) {\n          throw \"Runaway key\";\n        }\n        ;\n        // а-яА-Я is Cyrillic\n        //console.log(this.input[this.pos]);\n        if (this.notKey.indexOf(this.input[this.pos]) >= 0) {\n          if (optional && this.input[this.pos] != ',') {\n            this.pos = start;\n            return null;\n          }\n          ;\n          return this.input.substring(start, this.pos);\n        } else {\n          this.pos++;\n        }\n        ;\n      }\n      ;\n    };\n    this.key_equals_value = function () {\n      var key = this.key();\n      if (this.tryMatch(\"=\")) {\n        this.match(\"=\");\n        var val = this.value();\n        key = key.trim();\n        return [key, val];\n      } else {\n        throw \"... = value expected, equals sign missing:\" + this.input.substring(this.pos);\n      }\n      ;\n    };\n    this.key_value_list = function () {\n      var kv = this.key_equals_value();\n      this.currentEntry['entryTags'] = {};\n      this.currentEntry['entryTags'][kv[0]] = kv[1];\n      while (this.tryMatch(\",\")) {\n        this.match(\",\");\n        // fixes problems with commas at the end of a list\n        if (this.tryMatch(\"}\")) {\n          break;\n        }\n        ;\n        kv = this.key_equals_value();\n        this.currentEntry['entryTags'][kv[0]] = kv[1];\n      }\n      ;\n    };\n    this.entry_body = function (d) {\n      this.currentEntry = {};\n      this.currentEntry['citationKey'] = this.key(true);\n      this.currentEntry['entryType'] = d.substring(1);\n      if (this.currentEntry['citationKey'] != null) {\n        this.match(\",\");\n      }\n      this.key_value_list();\n      this.entries.push(this.currentEntry);\n    };\n    this.directive = function () {\n      this.match(\"@\");\n      return \"@\" + this.key();\n    };\n    this.preamble = function () {\n      this.currentEntry = {};\n      this.currentEntry['entryType'] = 'PREAMBLE';\n      this.currentEntry['entry'] = this.value_comment();\n      this.entries.push(this.currentEntry);\n    };\n    this.comment = function () {\n      this.currentEntry = {};\n      this.currentEntry['entryType'] = 'COMMENT';\n      this.currentEntry['entry'] = this.value_comment();\n      this.entries.push(this.currentEntry);\n    };\n    this.entry = function (d) {\n      this.entry_body(d);\n    };\n    this.alernativeCitationKey = function () {\n      this.entries.forEach(function (entry) {\n        if (!entry.citationKey && entry.entryTags) {\n          entry.citationKey = '';\n          if (entry.entryTags.author) {\n            entry.citationKey += entry.entryTags.author.split(',')[0] += ', ';\n          }\n          entry.citationKey += entry.entryTags.year;\n        }\n      });\n    };\n    this.bibtex = function () {\n      while (this.matchAt()) {\n        var d = this.directive();\n        this.match(\"{\");\n        if (d.toUpperCase() == \"@STRING\") {\n          this.string();\n        } else if (d.toUpperCase() == \"@PREAMBLE\") {\n          this.preamble();\n        } else if (d.toUpperCase() == \"@COMMENT\") {\n          this.comment();\n        } else {\n          this.entry(d);\n        }\n        this.match(\"}\");\n      }\n      ;\n      this.alernativeCitationKey();\n    };\n  }\n  ;\n  exports.toJSON = function (bibtex) {\n    var b = new BibtexParser();\n    b.setInput(bibtex);\n    b.bibtex();\n    return b.entries;\n  };\n\n  /* added during hackathon don't hate on me */\n  exports.toBibtex = function (json) {\n    var out = '';\n    for (var i in json) {\n      out += \"@\" + json[i].entryType;\n      out += '{';\n      if (json[i].citationKey) out += json[i].citationKey + ', ';\n      if (json[i].entry) out += json[i].entry;\n      if (json[i].entryTags) {\n        var tags = '';\n        for (var jdx in json[i].entryTags) {\n          if (tags.length != 0) tags += ', ';\n          tags += jdx + '= {' + json[i].entryTags[jdx] + '}';\n        }\n        out += tags;\n      }\n      out += '}\\n\\n';\n    }\n    return out;\n  };\n})(typeof exports === 'undefined' ? this['bibtexParse'] = {} : exports);\n\n/* end bibtexParse */","map":{"version":3,"names":["exports","BibtexParser","months","notKey","pos","input","entries","Array","currentEntry","setInput","t","getEntries","isWhitespace","s","match","canCommentOut","undefined","skipWhitespace","substring","length","tryMatch","matchAt","value_braces","bracecount","start","escaped","end","value_comment","str","brcktCnt","value_quotes","single_value","k","key","indexOf","toLowerCase","value","values","push","join","optional","key_equals_value","val","trim","key_value_list","kv","entry_body","d","directive","preamble","comment","entry","alernativeCitationKey","forEach","citationKey","entryTags","author","split","year","bibtex","toUpperCase","string","toJSON","b","toBibtex","json","out","i","entryType","tags","jdx"],"sources":["/Users/VPAVLOVI/Downloads/seqam-lab-site/node_modules/bibtex-parse-js/bibtexParse.js"],"sourcesContent":["/* start bibtexParse 0.0.24 */\n\n//Original work by Henrik Muehe (c) 2010\n//\n//CommonJS port by Mikola Lysenko 2013\n//\n//Port to Browser lib by ORCID / RCPETERS\n//\n//Issues:\n//no comment handling within strings\n//no string concatenation\n//no variable values yet\n//Grammar implemented here:\n//bibtex -> (string | preamble | comment | entry)*;\n//string -> '@STRING' '{' key_equals_value '}';\n//preamble -> '@PREAMBLE' '{' value '}';\n//comment -> '@COMMENT' '{' value '}';\n//entry -> '@' key '{' key ',' key_value_list '}';\n//key_value_list -> key_equals_value (',' key_equals_value)*;\n//key_equals_value -> key '=' value;\n//value -> value_quotes | value_braces | key;\n//value_quotes -> '\"' .*? '\"'; // not quite\n//value_braces -> '{' .*? '\"'; // not quite\n(function(exports) {\n\n    function BibtexParser() {\n\n        this.months = [\"jan\", \"feb\", \"mar\", \"apr\", \"may\", \"jun\", \"jul\", \"aug\", \"sep\", \"oct\", \"nov\", \"dec\"];\n        this.notKey = [',','{','}',' ','='];\n        this.pos = 0;\n        this.input = \"\";\n        this.entries = new Array();\n\n        this.currentEntry = \"\";\n\n        this.setInput = function(t) {\n            this.input = t;\n        };\n\n        this.getEntries = function() {\n            return this.entries;\n        };\n\n        this.isWhitespace = function(s) {\n            return (s == ' ' || s == '\\r' || s == '\\t' || s == '\\n');\n        };\n\n        this.match = function(s, canCommentOut) {\n            if (canCommentOut == undefined || canCommentOut == null)\n                canCommentOut = true;\n            this.skipWhitespace(canCommentOut);\n            if (this.input.substring(this.pos, this.pos + s.length) == s) {\n                this.pos += s.length;\n            } else {\n                throw \"Token mismatch, expected \" + s + \", found \"\n                        + this.input.substring(this.pos);\n            };\n            this.skipWhitespace(canCommentOut);\n        };\n\n        this.tryMatch = function(s, canCommentOut) {\n            if (canCommentOut == undefined || canCommentOut == null)\n                canCommentOut = true;\n            this.skipWhitespace(canCommentOut);\n            if (this.input.substring(this.pos, this.pos + s.length) == s) {\n                return true;\n            } else {\n                return false;\n            };\n            this.skipWhitespace(canCommentOut);\n        };\n\n        /* when search for a match all text can be ignored, not just white space */\n        this.matchAt = function() {\n            while (this.input.length > this.pos && this.input[this.pos] != '@') {\n                this.pos++;\n            };\n\n            if (this.input[this.pos] == '@') {\n                return true;\n            };\n            return false;\n        };\n\n        this.skipWhitespace = function(canCommentOut) {\n            while (this.isWhitespace(this.input[this.pos])) {\n                this.pos++;\n            };\n            if (this.input[this.pos] == \"%\" && canCommentOut == true) {\n                while (this.input[this.pos] != \"\\n\") {\n                    this.pos++;\n                };\n                this.skipWhitespace(canCommentOut);\n            };\n        };\n\n        this.value_braces = function() {\n            var bracecount = 0;\n            this.match(\"{\", false);\n            var start = this.pos;\n            var escaped = false;\n            while (true) {\n                if (!escaped) {\n                    if (this.input[this.pos] == '}') {\n                        if (bracecount > 0) {\n                            bracecount--;\n                        } else {\n                            var end = this.pos;\n                            this.match(\"}\", false);\n                            return this.input.substring(start, end);\n                        };\n                    } else if (this.input[this.pos] == '{') {\n                        bracecount++;\n                    } else if (this.pos >= this.input.length - 1) {\n                        throw \"Unterminated value\";\n                    };\n                };\n                if (this.input[this.pos] == '\\\\' && escaped == false)\n                    escaped = true;\n                else\n                    escaped = false;\n                this.pos++;\n            };\n        };\n\n        this.value_comment = function() {\n            var str = '';\n            var brcktCnt = 0;\n            while (!(this.tryMatch(\"}\", false) && brcktCnt == 0)) {\n                str = str + this.input[this.pos];\n                if (this.input[this.pos] == '{')\n                    brcktCnt++;\n                if (this.input[this.pos] == '}')\n                    brcktCnt--;\n                if (this.pos >= this.input.length - 1) {\n                    throw \"Unterminated value:\" + this.input.substring(start);\n                };\n                this.pos++;\n            };\n            return str;\n        };\n\n        this.value_quotes = function() {\n            this.match('\"', false);\n            var start = this.pos;\n            var escaped = false;\n            while (true) {\n                if (!escaped) {\n                    if (this.input[this.pos] == '\"') {\n                        var end = this.pos;\n                        this.match('\"', false);\n                        return this.input.substring(start, end);\n                    } else if (this.pos >= this.input.length - 1) {\n                        throw \"Unterminated value:\" + this.input.substring(start);\n                    };\n                }\n                if (this.input[this.pos] == '\\\\' && escaped == false)\n                    escaped = true;\n                else\n                    escaped = false;\n                this.pos++;\n            };\n        };\n\n        this.single_value = function() {\n            var start = this.pos;\n            if (this.tryMatch(\"{\")) {\n                return this.value_braces();\n            } else if (this.tryMatch('\"')) {\n                return this.value_quotes();\n            } else {\n                var k = this.key();\n                if (k.match(\"^[0-9]+$\"))\n                    return k;\n                else if (this.months.indexOf(k.toLowerCase()) >= 0)\n                    return k.toLowerCase();\n                else\n                    throw \"Value expected:\" + this.input.substring(start) + ' for key: ' + k;\n\n            };\n        };\n\n        this.value = function() {\n            var values = [];\n            values.push(this.single_value());\n            while (this.tryMatch(\"#\")) {\n                this.match(\"#\");\n                values.push(this.single_value());\n            };\n            return values.join(\"\");\n        };\n\n        this.key = function(optional) {\n            var start = this.pos;\n            while (true) {\n                if (this.pos >= this.input.length) {\n                    throw \"Runaway key\";\n                };\n                                // а-яА-Я is Cyrillic\n                //console.log(this.input[this.pos]);\n                if (this.notKey.indexOf(this.input[this.pos]) >= 0) {\n                    if (optional && this.input[this.pos] != ',') {\n                        this.pos = start;\n                        return null;\n                    };\n                    return this.input.substring(start, this.pos);\n                } else {\n                    this.pos++;\n\n                };\n            };\n        };\n\n        this.key_equals_value = function() {\n            var key = this.key();\n            if (this.tryMatch(\"=\")) {\n                this.match(\"=\");\n                var val = this.value();\n                key = key.trim()\n                return [ key, val ];\n            } else {\n                throw \"... = value expected, equals sign missing:\"\n                        + this.input.substring(this.pos);\n            };\n        };\n\n        this.key_value_list = function() {\n            var kv = this.key_equals_value();\n            this.currentEntry['entryTags'] = {};\n            this.currentEntry['entryTags'][kv[0]] = kv[1];\n            while (this.tryMatch(\",\")) {\n                this.match(\",\");\n                // fixes problems with commas at the end of a list\n                if (this.tryMatch(\"}\")) {\n                    break;\n                }\n                ;\n                kv = this.key_equals_value();\n                this.currentEntry['entryTags'][kv[0]] = kv[1];\n            };\n        };\n\n        this.entry_body = function(d) {\n            this.currentEntry = {};\n            this.currentEntry['citationKey'] = this.key(true);\n            this.currentEntry['entryType'] = d.substring(1);\n            if (this.currentEntry['citationKey'] != null) {\n                this.match(\",\");\n            }\n            this.key_value_list();\n            this.entries.push(this.currentEntry);\n        };\n\n        this.directive = function() {\n            this.match(\"@\");\n            return \"@\" + this.key();\n        };\n\n        this.preamble = function() {\n            this.currentEntry = {};\n            this.currentEntry['entryType'] = 'PREAMBLE';\n            this.currentEntry['entry'] = this.value_comment();\n            this.entries.push(this.currentEntry);\n        };\n\n        this.comment = function() {\n            this.currentEntry = {};\n            this.currentEntry['entryType'] = 'COMMENT';\n            this.currentEntry['entry'] = this.value_comment();\n            this.entries.push(this.currentEntry);\n        };\n\n        this.entry = function(d) {\n            this.entry_body(d);\n        };\n\n        this.alernativeCitationKey = function () {\n            this.entries.forEach(function (entry) {\n                if (!entry.citationKey && entry.entryTags) {\n                    entry.citationKey = '';\n                    if (entry.entryTags.author) {\n                        entry.citationKey += entry.entryTags.author.split(',')[0] += ', ';\n                    }\n                    entry.citationKey += entry.entryTags.year;\n                }\n            });\n        }\n\n        this.bibtex = function() {\n            while (this.matchAt()) {\n                var d = this.directive();\n                this.match(\"{\");\n                if (d.toUpperCase() == \"@STRING\") {\n                    this.string();\n                } else if (d.toUpperCase() == \"@PREAMBLE\") {\n                    this.preamble();\n                } else if (d.toUpperCase() == \"@COMMENT\") {\n                    this.comment();\n                } else {\n                    this.entry(d);\n                }\n                this.match(\"}\");\n            };\n\n            this.alernativeCitationKey();\n        };\n    };\n\n    exports.toJSON = function(bibtex) {\n        var b = new BibtexParser();\n        b.setInput(bibtex);\n        b.bibtex();\n        return b.entries;\n    };\n\n    /* added during hackathon don't hate on me */\n    exports.toBibtex = function(json) {\n        var out = '';\n        for ( var i in json) {\n            out += \"@\" + json[i].entryType;\n            out += '{';\n            if (json[i].citationKey)\n                out += json[i].citationKey + ', ';\n            if (json[i].entry)\n                out += json[i].entry ;\n            if (json[i].entryTags) {\n                var tags = '';\n                for (var jdx in json[i].entryTags) {\n                    if (tags.length != 0)\n                        tags += ', ';\n                    tags += jdx + '= {' + json[i].entryTags[jdx] + '}';\n                }\n                out += tags;\n            }\n            out += '}\\n\\n';\n        }\n        return out;\n\n    };\n\n})(typeof exports === 'undefined' ? this['bibtexParse'] = {} : exports);\n\n/* end bibtexParse */\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}